;; N178 2002-03-22

  1 DEPENDENT_MAP = 'dependent_map' .
  2 EACH = 'each' .
  3 ELSIF = 'elsif' .
  4 END_DEPENDENT_MAP = 'end_dependent_map' .
  5 END_MAP = 'end_map' .
  6 END_SCHEMA_MAP = 'end_schema_map' .
  7 END_SCHEMA_VIEW = 'end_schema_view' .
  8 END_VIEW = 'end_view' .
  9 EXTENT = 'extent' .
 10 IDENTIFIED_BY = 'identified_by' .
 11 INDEXING = 'indexing' .
 12 MAP = 'map' .
 13 ORDERED_BY = 'ordered_by' .
 14 PARTITION = 'partition' .
 15 SCHEMA_MAP = 'schema_map' .
 16 SCHEMA_VIEW = 'schema_view' .
 17 SOURCE = 'source' .
 18 TARGET = 'target' .
 19 VIEW = 'view' .
 20 digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
 21 letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' .
 22 simple_id = letter { letter | digit | '_' } .
 23 partition_ref = partition_id .
 24 schema_map_ref = schema_map_id .
 25 schema_view_ref = schema_view_id .
 26 source_schema_ref = schema_ref .
 27 target_schema_ref = schema_ref .
 28 view_attribute_ref = view_attribute_id .
 29 view_ref = view_id .
 30 abstract_supertype_declaration = ABSTRACT SUPERTYPE [ subtype_constraint ] .
 31 actual_parameter_list = '(' parameter { ',' parameter } ')' .
 32 add_like_op = '+' | '-' | OR | XOR .
 33 aggregate_initializer = '[' [ element { ',' element } ] ']' .
 34 aggregate_source = simple_expression .
 35 aggregate_type = AGGREGATE [ ':' type_label ] OF parameter_type .
 36 aggregation_types = array_type | bag_type | list_type | set_type .
 37 algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
 38 array_type = ARRAY bound_spec OF [ OPTIONAL ] [ UNIQUE ] base_type .
 39 assignment_stmt = general_ref { qualifier } ':=' expression ';' .
 40 backward_path_qualifier = '<-' [ attribute_ref ] path_condition .
 41 bag_type = BAG [ bound_spec ] OF base_type .
 42 base_type = aggregation_types | simple_types | named_types .
 43 binary_type = BINARY [ width_spec ] .
 44 binding_header = [ PARTITION partition_id ';' ] [ from_clause ] [ local_decl ] [ where_clause ] [ identified_by_clause ] [ ordered_by_clause ] .
 45 boolean_type = BOOLEAN .
 46 bound_1 = numeric_expression .
 47 bound_2 = numeric_expression .
 48 bound_spec = '[' bound_1 ':' bound_2 ']' .
 49 built_in_constant = CONST_E | PI | SELF | '?' .
 50 built_in_function = ABS | ACOS | ASIN | ATAN | BLENGTH | COS | EXISTS | EXTENT | EXP | FORMAT | HIBOUND | HIINDEX | LENGTH | LOBOUND | LOINDEX | LOG | LOG2 | LOG10 | NVL | ODD | ROLESOF | SIN | SIZEOF | SQRT | TAN | TYPEOF | USEDIN | VALUE | VALUE_IN | VALUE_UNIQUE .
 51 built_in_procedure = INSERT | REMOVE .
 52 case_action = case_label { ',' case_label } ':' stmt .
 53 case_expr = CASE selector OF { case_expr_action } [ OTHERWISE ':' expression ] END_CASE .
 54 case_expr_action = case_label { ',' case_label } ':' expression ';' .
 55 case_label = expression .
 56 case_stmt = CASE selector OF { case_action } [ OTHERWISE ':' stmt ] END_CASE ';' .
 57 compound_stmt = BEGIN stmt { stmt } END ';' .
 58 constant_body = constant_id ':' base_type ':=' expression ';' .
 59 constant_decl = CONSTANT constant_body { constant_body } END_CONSTANT ';' .
 60 constant_factor = built_in_constant | constant_ref .
 61 constant_id = simple_id .
 62 declaration = function_decl | procedure_decl .
 63 dependent_map_decl = DEPENDENT_MAP map_id AS target_parameter ';' { target_parameter ';' } [ map_subtype_of_clause ] dep_map_partition { dep_map_partition } END_DEPENDENT_MAP ';' .
 64 dep_binding_decl = dep_from_clause [ local_decl ] [ where_clause ] [ ordered_by_clause ] .
 65 dep_from_clause = FROM dep_source_parameter ';' { dep_source_parameter ';' } .
 66 dep_map_decl_body = dep_binding_decl map_project_clause .
 67 dep_map_partition = [ PARTITION partition_id ':' ] dep_map_decl_body .
 68 dep_source_parameter = source_parameter_id { ',' source_parameter_id } ':' ( simple_types | type_reference ) .
 69 domain_rule = [ label ':' ] logical_expression .
 70 element = expression [ ':' repetition ] .
 71 entity_constructor = entity_reference '(' [ expression { ',' expression } ] ')' .
 72 entity_id = simple_id .
 73 entity_instantiation_loop = FOR instantiation_loop_control ';' map_project_clause .
 74 entity_reference = [ ( source_schema_ref | target_schema_ref | schema_ref ) '.' ] entity_ref .
 75 enumeration_reference = [ type_reference '.' ] enumeration_ref .
 76 escape_stmt = ESCAPE ';' .
 77 expression = simple_expression [ rel_op_extended simple_expression ] .
 78 expression_or_wild = expression | '_' .
 79 extent_reference = source_entity_reference | view_reference .
 80 factor = simple_factor [ '**' simple_factor ] .
 81 foreach_expr = EACH variable_id IN expression [ where_clause ] RETURN expression .
 82 forloop_expr = repeat_control RETURN expression .
 83 formal_parameter = parameter_id { ',' parameter_id } ':' parameter_type .
 84 forward_path_qualifier = '::' attribute_ref [ path_condition ] .
 85 for_expr = FOR ( foreach_expr | forloop_expr ) .
 86 from_clause = FROM source_parameter ';' { source_parameter ';' } .
 87 function_call = ( built_in_function | function_ref ) [ actual_parameter_list ] .
 88 function_decl = function_head [ algorithm_head ] stmt { stmt } END_FUNCTION ';' .
 89 function_head = FUNCTION function_id [ '(' formal_parameter { ';' formal_parameter } ')' ] ':' parameter_type ';' .
 90 function_id = simple_id .
 91 generalized_types = aggregate_type | general_aggregation_types | generic_type .
 92 general_aggregation_types = general_array_type | general_bag_type | general_list_type | general_set_type .
 93 general_array_type = ARRAY [ bound_spec ] OF [ OPTIONAL ] [ UNIQUE ] parameter_type .
 94 general_attribute_qualifier = '.' ( attribute_ref | view_attribute_ref ) .
 95 general_bag_type = BAG [ bound_spec ] OF parameter_type .
 96 general_list_type = LIST [ bound_spec ] OF [ UNIQUE ] parameter_type .
 97 general_or_map_call = general_ref [ '@' map_call ] .
 98 general_ref = parameter_ref | variable_ref .
 99 general_schema_alias_id = schema_id | schema_map_id | schema_view_id .
100 general_schema_ref = schema_ref | schema_map_ref | schema_view_ref .
101 general_set_type = SET [ bound_spec ] OF parameter_type .
102 generic_type = GENERIC [ ':' type_label ] .
103 group_qualifier = '\' entity_ref .
104 identified_by_clause = IDENTIFIED_BY id_parameter ';' { id_parameter ';' } .
105 id_parameter = [ id_parameter_id ':' ] expression .
106 id_parameter_id = parameter_id .
107 if_expr = IF logical_expression THEN expression { ELSIF logical_expression expression } [ ELSE expression ] END_IF .
108 if_stmt = IF logical_expression THEN stmt { stmt } [ ELSE stmt { stmt } ] END_IF ';' .
109 increment = numeric_expression .
110 increment_control = variable_id ':=' bound_1 TO bound_2 [ BY increment ] .
111 index = numeric_expression .
112 index_1 = index .
113 index_2 = index .
114 index_qualifier = '[' index_1 [ ':' index_2 ] ']' .
115 instantiation_foreach_control = EACH variable_id IN source_attribute_reference INDEXING variable_id .
116 instantiation_loop_control = instantiation_foreach_control | repeat_control .
117 integer_type = INTEGER .
118 interval = '{' interval_low interval_op interval_item interval_op interval_high '}' .
119 interval_high = simple_expression .
120 interval_item = simple_expression .
121 interval_low = simple_expression .
122 interval_op = '<' | '<=' .
123 label = simple_id .
124 list_type = LIST [ bound_spec ] OF [ UNIQUE ] base_type .
125 literal = binary_literal | integer_literal | logical_literal | real_literal | string_literal .
126 local_decl = LOCAL local_variable { local_variable } END_LOCAL ';' .
127 local_variable = variable_id { ',' variable_id } ':' parameter_type [ ':=' expression ] ';' .
128 logical_expression = expression .
129 logical_literal = FALSE | TRUE | UNKNOWN .
130 logical_type = LOGICAL .
131 map_attribute_declaration = ( [ target_parameter_ref [ index_qualifier ] [ group_qualifier ] '.' ] attribute_ref [ index_qualifier ]) | ( variable_id [ index_qualifier ] [ [ group_qualifier ] '.' attribute_ref [ index_qualifier ] ] ) ':=' expression ';' .
132 map_call = map_ref [ partition_qualification ] '(' expression_or_wild { ',' expression_or_wild } ')' .
133 map_decl = MAP map_id AS target_parameter ';' { target_parameter ';' } ( map_subtype_of_clause subtype_binding_header map_decl_body ) | ( binding_header map_decl_body { binding_header map_decl_body } ) END_MAP ';' .
134 map_decl_body = ( entity_instantiation_loop { entity_instantiation_loop } ) | map_project_clause | ( RETURN expression ';' ) .
135 map_id = simple_id .
136 map_project_clause = SELECT map_attribute_declaration { map_attribute_declaration } .
137 map_ref = map_id .
138 map_reference = [ schema_map_ref '.' ] map_ref .
139 map_subtype_of_clause = SUBTYPE OF '(' map_reference ')' ';' .
140 multiplication_like_op = '*' | '/' | DIV | MOD | AND | '||' .
141 named_types = entity_reference | type_reference | view_reference .
142 null_stmt = ';' .
143 number_type = NUMBER .
144 numeric_expression = simple_expression .
145 one_of = ONEOF '(' supertype_expression { ',' supertype_expression } ')' .
146 ordered_by_clause = ORDERED_BY expression { ',' expression } ';' .
147 parameter = expression .
148 parameter_id = simple_id .
149 parameter_type = generalized_types | named_types | simple_types .
150 partition_id = simple_id .
151 partition_qualification = '\' partition_ref .
152 path_condition = '{' extent_reference [ '|' logical_expression ] '}' .
153 path_qualifier = forward_path_qualifier | backward_path_qualifier .
154 population = entity_reference .
155 precision_spec = numeric_expression .
156 primary = literal | ( qualifiable_factor { qualifier } ) .
157 procedure_call_stmt = ( built_in_procedure | procedure_ref ) [ actual_parameter_list ] ';' .
158 procedure_decl = procedure_head [ algorithm_head ] { stmt } END_PROCEDURE ';' .
159 procedure_head = PROCEDURE procedure_id [ '(' [ VAR ] formal_parameter { ';' [ VAR ] formal_parameter } ')' ] ';' .
160 procedure_id = simple_id .
161 qualifiable_factor = attribute_ref | constant_factor | function_call | general_or_map_call | population | view_attribute_ref | view_call .
162 qualifier = general_attribute_qualifier | group_qualifier | index_qualifier | path_qualifier .
163 query_expression = QUERY '(' variable_id '<*' aggregate_source '|' logical_expression ')' .
164 real_type = REAL [ '(' precision_spec ')' ] .
165 reference_clause = REFERENCE FROM schema_ref_or_rename [ '(' resource_or_rename { ',' resource_or_rename } ')' ] [ AS ( SOURCE | TARGET ) ] ';' .
166 rel_op = '<' | '>' | '<=' | '>=' | '<>' | '=' | ':<>:' | ':=:' .
167 rel_op_extended = rel_op | IN | LIKE .
168 rename_id = constant_id | entity_id | function_id | procedure_id | type_id .
169 repeat_control = [ increment_control ] [ while_control ] [ until_control ] .
170 repeat_stmt = REPEAT repeat_control ';' stmt { stmt } END_REPEAT ';' .
171 repetition = numeric_expression .
172 resource_or_rename = resource_ref [ AS rename_id ] .
173 resource_ref = constant_ref | entity_ref | function_ref | procedure_ref | type_ref | view_ref | map_ref .
174 return_stmt = RETURN [ '(' expression ')' ] ';' .
175 rule_decl = rule_head [ algorithm_head ] { stmt } where_clause END_RULE ';' .
176 rule_head = RULE rule_id FOR '(' entity_ref { ',' entity_ref } ')' ';' .
177 rule_id = simple_id .
178 schema_id = simple_id .
179 schema_map_body_element = function_decl | procedure_decl | view_decl | map_decl | dependent_map_decl | rule_decl .
180 schema_map_body_element_list = schema_map_body_element { schema_map_body_element } .
181 schema_map_decl = SCHEMA_MAP schema_map_id ';' reference_clause { reference_clause } [ constant_decl ] schema_map_body_element_list END_SCHEMA_MAP ';' .
182 schema_map_id = simple_id .
183 schema_ref_or_rename = [ general_schema_alias_id ':' ] general_schema_ref .
184 schema_view_body_element = function_decl | procedure_decl | view_decl | rule_decl .
185 schema_view_body_element_list = schema_view_body_element { schema_view_body_element } .
186 schema_view_decl = SCHEMA_VIEW schema_view_id ';' { reference_clause } [ constant_decl ] schema_view_body_element_list END_SCHEMA_VIEW ';' .
187 schema_view_id = simple_id .
188 selector = expression .
189 set_type = SET [ bound_spec ] OF base_type .
190 simple_expression = term { add_like_op term } .
191 simple_factor = aggregate_initializer | entity_constructor | enumeration_reference | interval | query_expression | ( [ unary_op ] ( '(' expression ')' | primary ) ) | case_expr | for_expr | if_expr .
192 simple_types = binary_type | boolean_type | integer_type | logical_type | number_type | real_type | string_type .
193 skip_stmt = SKIP ';' .
194 source_attribute_reference = parameter_ref '.' ( attribute_ref | view_attribute_ref ) .
195 source_entity_reference = entity_reference .
196 source_parameter = source_parameter_id ':' extent_reference .
197 source_parameter_id = parameter_id .
198 stmt = assignment_stmt | case_stmt | compound_stmt | escape_stmt | if_stmt | null_stmt | procedure_call_stmt | repeat_stmt | return_stmt | skip_stmt .
199 string_literal = simple_string_literal | encoded_string_literal .
200 string_type = STRING [ width_spec ] .
201 subsuper = [ supertype_constraint ] [ subtype_declaration ] .
202 subtype_binding_header = [ PARTITION partition_id ';' ] where_clause .
203 subtype_constraint = OF '(' supertype_expression ')' .
204 subtype_declaration = SUBTYPE OF '(' view_ref { ',' view_ref } ')' .
205 supertype_constraint = abstract_supertype_declaration | supertype_rule .
206 supertype_expression = supertype_factor { ANDOR supertype_factor } .
207 supertype_factor = supertype_term { AND supertype_term } .
208 supertype_rule = SUPERTYPE [ subtype_constraint ] .
209 supertype_term = view_ref | one_of | '(' supertype_expression ')' .
210 syntax_x = schema_map_decl | schema_view_decl .
211 target_entity_reference = entity_reference { '&' entity_reference } .
212 target_parameter = target_parameter_id { ',' target_parameter_id } ':' [ AGGREGATE [ bound_spec ] OF ] target_entity_reference .
213 target_parameter_id = parameter_id .
214 target_parameter_ref = target_parameter_id .
215 term = factor { multiplication_like_op factor } .
216 type_id = simple_id .
217 type_label = type_label_id | type_label_ref .
218 type_label_id = simple_id .
219 type_reference = [ schema_ref '.' ] type_ref .
220 unary_op = '+' | '-' | NOT .
221 until_control = UNTIL logical_expression .
222 variable_id = simple_id .
223 view_attribute_decl = view_attribute_id ':' [ OPTIONAL ] [ source_schema_ref '.' ] base_type ':=' expression ';' .
224 view_attribute_id = simple_id .
225 view_attr_decl_stmt_list = view_attribute_decl { view_attribute_decl } .
226 view_call = view_reference [ partition_qualification ] '(' [ expression_or_wild { ',' expression_or_wild } ] ')' .
227 view_decl = VIEW view_id [ ':' base_type ] subsuper ';' ( subtype_binding_header view_project_clause { subtype_binding_header view_project_clause } ) | ( binding_header view_project_clause { binding_header view_project_clause } ) END_VIEW ';' .
228 view_id = simple_id .
229 view_project_clause = ( SELECT view_attr_decl_stmt_list ) | ( RETURN expression ) .
230 view_reference = [ ( schema_map_ref | schema_view_ref ) '.' ] view_ref .
231 where_clause = WHERE domain_rule ';' { domain_rule ';' } .
232 while_control = WHILE logical_expression .
233 width = numeric_expression .
234 width_spec = '(' width ')' [ FIXED ] .
