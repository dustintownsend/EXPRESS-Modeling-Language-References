;; ISO 10303-11:1994

ABS		= 'abs' .
ABSTRACT	= 'abstract' .
ACOS		= 'acos' .
AGGREGATE	= 'aggregate' .
ALIAS		= 'alias' .
AND		= 'and' .
ANDOR		= 'andor' .
ARRAY		= 'array' .
AS		= 'as' .
ASIN		= 'asin' .
ATAN		= 'atan' .
BAG		= 'bag' .
BEGIN		= 'begin' .
BINARY		= 'binary' .
BLENGTH		= 'blength' .
BOOLEAN		= 'boolean' .
BY		= 'by' .
CASE		= 'case' .
CONST_E		= 'const_e' .
CONSTANT	= 'constant' .
CONTEXT		= 'context' .
COS		= 'cos' .
DERIVE		= 'derive' .
DIV		= 'div' .
ELSE		= 'else' .
END		= 'end' .
END_ALIAS	= 'end_alias' .
END_CASE	= 'end_case' .
END_CONSTANT	= 'end_constant' .
END_CONTEXT	= 'end_context' .
END_ENTITY	= 'end_entity' .
END_FUNCTION	= 'end_function' .
END_IF		= 'end_if' .
END_LOCAL	= 'end_local' .
END_MODEL	= 'end_model' .
END_PROCEDURE	= 'end_procedure' .
END_REPEAT	= 'end_repeat' .
END_RULE	= 'end_rule' .
END_SCHEMA	= 'end_schema' .
END_TYPE	= 'end_type' .
ENTITY		= 'entity' .
ENUMERATION	= 'enumeration' .
ESCAPE		= 'escape' .
EXISTS		= 'exists' .
EXP		= 'exp' .
FALSE		= 'false' .
FIXED		= 'fixed' .
FOR		= 'for' .
FORMAT		= 'format' .
FROM		= 'from' .
FUNCTION	= 'function' .
GENERIC		= 'generic' .
HIBOUND		= 'hibound' .
HIINDEX		= 'hiindex' .
IF		= 'if' .
IN		= 'in' .
INSERT		= 'insert' .
INTEGER		= 'integer' .
INVERSE		= 'inverse' .
LENGTH		= 'length' .
LIKE		= 'like' .
LIST		= 'list' .
LOBOUND		= 'lobound' .
LOINDEX		= 'loindex' .
LOCAL		= 'local' .
LOG		= 'log' .
LOG10		= 'log10' .
LOG2		= 'log2' .
LOGICAL		= 'logical' .
MOD		= 'mod' .
MODEL		= 'model' .
NOT		= 'not' .
NUMBER		= 'number' .
NVL		= 'nvl' .
ODD		= 'odd' .
OF		= 'of' .
ONEOF		= 'oneof' .
OPTIONAL	= 'optional' .
OR		= 'or' .
OTHERWISE	= 'otherwise' .
PI		= 'pi' .
PROCEDURE	= 'procedure' .
QUERY		= 'query' .
REAL		= 'real' .
REFERENCE	= 'reference' .
REMOVE		= 'remove' .
REPEAT		= 'repeat' .
RETURN		= 'return' .
ROLESOF		= 'rolesof' .
RULE		= 'rule' .
SCHEMA		= 'schema' .
SELECT		= 'select' .
SELF		= 'self' .
SET		= 'set' .
SIN		= 'sin' .
SIZEOF		= 'sizeof' .
SKIP		= 'skip' .
SQRT		= 'sqrt' .
STRING		= 'string' .
SUBTYPE		= 'subtype' .
SUPERTYPE	= 'supertype' .
TAN		= 'tan' .
THEN		= 'then' .
TO		= 'to' .
TRUE		= 'true' .
TYPE		= 'type' .
TYPEOF		= 'typeof' .
UNIQUE		= 'unique' .
UNKNOWN		= 'unknown' .
UNTIL		= 'until' .
USEDIN		= 'usedin' .
USE		= 'use' .
VALUE		= 'value' .
VAR		= 'var' .
WHERE		= 'where' .
WHILE		= 'while' .
XOR		= 'xor' .
bit = '0' | '1' .
digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'.
digits = digit { digit } .
encoded_character = octet octet octet octet .
hex_digit = digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' .
leter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'.
lparen_not_star = '(' not_star .
not_lparen_star = not_paren_star | ')' .
not_paren_star = letter | digit | not_paren_star_special .
not_paren_star_quote_special = '!' | '"' | '#' | '$' | '%' | '&' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '\' | '^' | '_' | '''' | '{' | '|' | '}' | '~' | '[' | ']' .
not_paren_star_special = not_paren_star_quote_special | '''' .
not_quote = not_paren_star_quote_special | letter | digit | '(' | ')' | '*' .
not_rparen = not_paren_star | '*' | '(' .
not_star = not_paren_star | '(' | ')' .
octet = hex_digit hex_digit .
special = not_paren_star_quote_special | '(' | ')' | '*' | '''' .
star_not_rparen = '*' not_rparen .
binary_literal = '%' bit { bit } .
encoded_string_literal = '"' encoded_character { encoded_character } '"' .
integer_literal = [ sign ] digits .
real_literal = [ sign ] digits '.' [ digits ] [ 'e' [ sign ] digits ] .
simple_id = letter { letter | digit | '_' } .
simple_string_literal = \q { ( \q \q ) | not_quote | \s | \o } \q .
embedded_remark = '(*' { not_lparen_star | lparen_not_star | star_not_rparen | embedded_remark } '*)' .
remark = embedded_remark | tail_remark .
tail_remark = '--' { \a | \s | \o } \n .
alias_ref = alias_id .
attribute_ref = attribute_id .
constant_ref = constant_id .
entity_ref = entity_id .
enumeration_ref = enumeration_id .
function_ref = function_id .
parameter_ref = parameter_id .
procedure_ref = procedure_id .
schema_ref = schema_id .
type_ref = type_id .
variable_ref = variable_id .
add_like_op = '+' | '-' | OR | XOR .
actual_parameter_list = '(' parameter { ',' parameter } ')' .
aggregate_initializer = '[' [ element { ',' element } ] ']' .
aggregate_source = simple_expression .
aggregate_type = AGGREGATE [ ':' type_label ] OF parameter_type .
aggregation_types = array_type | bag_type | list_type | set_type .
algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
alias_id = simple_id .
alias_stmt = ALIAS alias_id FOR general_ref { qualifier } ';' stmt { stmt } END_ALIAS ';' .
array_type = ARRAY bound_spec OF [ OPTIONAL ] [ UNIQUE ] base_type .
assignment_stmt = general_ref { qualifier } ':=' expression ';' .
attribute_decl = attribute_id | qualified_attribute .
attribute_id = simple_id .
attribute_qualifier = '.' attribute_ref .
bag_type = BAG [ bound_spec ] OF base_type .
base_type = aggregation_types | simple_types | named_types .
binary_type = BINARY [ '(' width ')' [ FIXED ] ] .
boolean_type = BOOLEAN .
bound_1 = numeric_expression .
bound_2 = '?' | numeric_expression .
bound_spec = '[' bound_1 ':' bound_2 ']' .
built_in_constant = CONST_E | PI | SELF | '?' .
build_in_function = ABS | ACOS | ASIN | ATAN | BLENGTH | COS | EXISTS | EXP | FORMAT | HIBOUND | HIINDEX | LENGTH | LOBOUND | LOINDEX | LOG | LOG2 | LOG10 | NVL | ODD | ROLESOF | SIN | SIZEOF | SQRT | TAN | TYPEOF | USEDIN | VALUE .
built_in_procedure = INSERT | REMOVE .
case_action = case_label { ',' case_label } ':' stmt .
case_label = expression .
case_stmt = CASE selector OF { case_action } [ OTHERWISE ':' stmt ] END_CASE ';' .
compound_stmt = BEGIN stmt { stmt } END ';' .
constant_decl = CONSTANT constant_body { constant_body } END_CONSTANT ';' .
constant_body = constant_id ':' base_type ':=' expression ';' .
constant_factor = built_in_constant | constant_ref .
constant_id = simple_id .
constructed_types = enumeration_type | select_type .
declaration = entity_decl | function_decl | procedure_decl | type_decl .
derive_attr = attribute_decl ':' base_type ':=' expression ';' .
derive_clause = DERIVE derived_attr { derived_attr } .
domain_rule = [ label ':' ] expression .
element = expression [ ':' repetition ] .
entity_decl = entity_head entity_body END_ENTITY ';' .
entity_body = {explicit_attr} [derive_clause] [inverse_clause] [unique_clause] [where_clause] .
entity_head = ENTITY entity_id [subsuper] ';' .
entity_id = simple_id .
entity_constructor = entity_ref '(' [ expression { ',' expression } ] ')' .
enumeration_id = simple_id .
enumeration_reference = [ type_ref '.' ] enumeration_ref .
enumeration_type = ENUMERATION OF '(' enumeration_id { ',' enumeration_id } ')' .
escape_stmt = ESCAPE ';' .
explicit_attr = attribute_decl { ',' attribute_decl } ':' [ OPTIONAL ] base_type ';' .
expression = simple_expression [ rel_op_extended simple_expression ] .
factor = simple_factor [ '**' simple_factor ] .
formal_parameter = parameter_id { ',' parameter_id } ':' parameter_type .
function_decl = function_head [ algorithm_head ] stmt { stmt } END_FUNCTION ';' .
function_call = ( built_in_function | function_ref ) [ actual_parameter_list ] .
function_head = FUNCTION function_id [ '(' formal_parameter { ';' formal_parameter } ')' ] ':' parameter_type ';' .
function_id = simple_id .
general_aggregation_types = general_array_type | general_bag_type | general_list_type | general_set_type .
general_array_type = ARRAY [ bound_spec ] OF [ OPTIONAL ] [ UNIQUE ] parameter_type .
general_bag_type = BAG [ bound_spec ] OF parameter_type .
general_list_type = LIST [ bound_spec ] OF [ UNIQUE ] parameter_type .
general_ref = alias_ref | parameter_ref | variable_ref .
general_set_type = SET [ bound_spec ] OF parameter_type .
generalized_types = aggregate_type | general_aggregation_types | generic_type .
generic_type = GENERIC [ ':' type_label ] .
group_qualifier = '\' entity_ref .
if_stmt = IF logical_expression THEN stmt { stmt } [ ELSE stmt { stmt } ] END_IF ';' .
increment = numeric_expression .
increment_control = variable_id ':=' bound_1 TO bound_2 [ BY increment ] .
index = numeric_expression .
integer_type = INTEGER .
interface_specification = reference_clause | use_clause .
interval = '{' interval_item interval_op  interval_item interval_op interval_item '}' .
interval_item = simple_expression .
interval_op = '<' | '<=' .
inverse_attr = attribute_id ':' [ ( SET | BAG ) [ bound_spec ] OF ] entity_ref FOR attribute_ref ';' .
inverse_clause = INVERSE inverse_attr { inverse_attr } .
label = simple_id .
list_type = LIST [ bound_spec ] OF [ UNIQUE ] base_type .
literal = binary_literal | integer_literal | logical_literal | real_literal | string_literal .
local_decl = LOCAL local_variable { local_variable } END_LOCAL ';' .
local_variable = variable_id { ',' variable_id } ':' parameter_type [ ':=' expression ] ';' .
logical_expression = expression .
logical_literal = FALSE | TRUE | UNKNOWN .
logical_type = LOGICAL .
multiplication_like_op = '*' | '/' | DIV | MOD | AND | '||' .
named_types = entity_ref | type_ref .
named_type_or_rename = named_types [ AS ( entity_id | type_id ) ] .
null_stmt = ';' .
number_type = NUMBER .
numeric_expression = simple_expression .
one_of = ONEOF '(' entity_ref { ',' entity_ref } ')' .
parameter = expression .
parameter_id = simple_id .
parameter_type = generalized_types | named_types | simple_types .
population = entity_ref .
precision_spec = numeric_expression .
primary = literal | ( qualifiable_factor { qualifier } ) .
procedure_decl = procedure_head [ algorithm_head ] { stmt } END_PROCEDURE ';' .
procedure_call_stmt = ( built_in_procedure | procedure_ref ) [ actual_parameter_list ] ';' .
procedure_head = PROCEDURE procedure_id [ '(' [ VAR ] formal_parameter { ';' [ VAR ] formal_parameter } ')' ] ';' .
procedure_id = simple_id .
qualifier = attribute_qualifier | group_qualifier | subcomponent_qualifier .
qualifiable_factor = attribute_ref | constant_factor | function_call | general_ref | population .
qualified_attribute = SELF group_qualifier attribute_qualifier .
query_expression = QUERY '(' variable_id '<*' aggregate_source '|' logical_expression ')' .
real_type = REAL [ '(' precision_spec ')' ] .
reference_clause = REFERENCE FROM schema_ref [ '(' resource_or_rename { ',' resource_or_rename } ')' ] ';' .
referenced_attribute = attribute_ref | qualified_attribute .
rel_op = '<' | '>' | '<=' | '>=' | '<>' | '=' | ':<>:' | ':=:' .
rel_op_extended = rel_op | IN | LIKE .
rename_id = entity_id | function_id | procedure_id | type_id .
repeat_control = [ increment_control ] [ while_control ] [ until_control ] .
repeat_stmt = REPEAT repeat_control ';' stmt { stmt } END_REPEAT ';' .
repetition = numeric_expression .
resource_or_rename = resource_ref [ AS rename_id ] .
resource_ref = constant_ref | entity_ref | function_ref | procedure_ref | type_ref .
return_stmt = RETURN [ '(' expression ')' ] ';' .
rule_decl = rule_head [ algorithm_head ] { stmt } where_clause END_RULE ';' .
rule_head = RULE rule_id FOR '(' entity_ref { ',' entity_ref  } ')' ';' .
rule_id = simple_id .
schema_decl = SCHEMA schema_id [ schema_version_id ] ';' schema_body END_SCHEMA ';' .
schema_body = { interface_specification } [ constant_decl ] { declaration | rule_decl } .
schema_id = simple_id .
schema_version_id = string_literal .
select_type = SELECT '(' named_types { ',' named_types } ')' .
selector = expression .
set_type = SET [ bound_spec ] OF base_type .
sign = '+' | '-' .
simple_expression = term { add_like_op term } .
simple_factor = aggregate_initializer | entity_constructor | enumeration_reference | interval | query_expression | ( [ NOT ] '(' expression ')' ) | ( [ unary_op ] primary ) .
simple_types = binary_type | boolean_type | integer_type | logical_type | number_type | real_type | string_type .
skip_stmt = SKIP ';' .
stmt = alias_stmt | assignment_stmt | case_stmt | compound_stmt | escape_stmt | if_stmt | null_stmt | procedure_call_stmt | repeat_stmt | return_stmt | skip_stmt .
string_literal = simple_string_literal | encoded_string_literal .
string_type = STRING [ '(' width ')' [ FIXED ] ] .
subcomponent_qualifier = '[' index [ ':' index ] ']' .
subsuper = [ supertype_declaration ] [ subtype_declaration ] .
subtype_declaration = SUBTYPE OF '(' entity_ref { ',' entity_ref } ')' .
supertype_declaration = ABSTRACT SUPERTYPE [ OF '(' supertype_expression ')' ] | SUPERTYPE OF '(' supertype_expression ')' .
supertype_expression = supertype_factor { ( AND | ANDOR ) supertype_factor } .
supertype_factor = entity_ref | one_of | '(' supertype_expression ')' .
term = factor { multiplication_like_op factor } .
type_decl = TYPE type_id '=' underlying_type ';' [ where_clause ] END_TYPE ';' .
type_id = simple_id .
type_label = simple_id .
unary_op = '+' | '-' | NOT .
underlying_type = constructed_types | aggregation_types | simple_types | type_ref .
unique_clause = UNIQUE unique_rule ';' { unique_rule ';' } .
unique_rule = [ label ':' ] referenced_attribute { ',' referenced_attribute } .
until_control = UNTIL logical_expression .
use_clause = USE FROM schema_ref [ '(' named_type_or_rename { ',' named_type_or_rename } ')' ] ';' .
variable_id = simple_id .
where_clause = WHERE domain_rule ';' { domain_rule ';' } .
while_control = WHILE logical_expression .
width = numeric_expression .
